library(shiny)
runApp(ksuave)
setwd("~/shinyexamples")
runApp(ksuave)
runApp("ksuave")
runApp("ksuave")
runApp("ksuave")
runApp("ksuave")
runApp("ksuave")
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
?seq
shiny::runApp('ksuave')
shiny::runApp('ksuave')
shiny::runApp('ksuave')
qnorm(.1)
shiny::runApp()
install.packages("shiny")
choices=c("Uniforme"="box", "Normal"="normal")),
shiny::runApp()
setwd("~/Master/mineria/p1/ksuave")
setwd("~/Master/mineria/p1")
# Modelo simulado
###############
set.seed(353)
N = 100
x = sort(runif(N))
y = rnorm(N,sin(4*x),1/3)
plot(x,y,main="Regresi?n y Suavizadores")
x2 = seq(0,1,length=1000)
lines(x2,sin(4*x2))
d = data.frame(x=x,y=y)
#######################
# Modelado param?trico
#######################
## funci?n que construye la matriz del dise?o asociado a polinomios trigonometricos
#
# Periodic model using sines and cosines
#
cs <- function(t,harmonics=1) {
# generate matrix with sin,cos pairs with period 1
ret <- numeric(0)
for ( i in harmonics) {
ret <- cbind( ret, cos(2*pi*i*t), sin(2*pi*i*t))
}
if (missing(harmonics)) cnames <- c('c','s')
else {
cnames <- paste( c("c","s"), rep(harmonics, each = 2),sep=".")
}
colnames(ret) <- cnames
ret
}
# Ajustes con diferente grado de complejidad
fit.cs= lm(y~cs(x),d)
summary(fit.cs)   # can we drop a term??
anova(fit.cs)     # here anova respects 'marginality'
plot( d$x, d$y)
dtest=data.frame(x=x2)
lines( x2 , predict(fit.cs,dtest),col='red')
lines( x2, predict( lm( y ~ cs(x,1:4),d),dtest),col='green')
lines( x2, predict( lm( y ~ cs(x,1:8),d),dtest), col = 'black',lwd=1.5)
lines( x2, predict( lm( y ~ cs(x,1:18),d),dtest), col = 'blue',lwd=1.5)
lines( x2, predict( fit.cs <- lm( y ~ cs(x,1:50),d),dtest), col = 'purple',lwd=1.5)
summary(fit.cs)
# seleccion del mejor modelo
## Using adjusted R2
require(stats4)
measures <- matrix(NA,nrow=50,ncol=8,
,dimnames=list(NULL,c("H","df","R.sq","Adj.R.sq","logLik",
"-2logLik","AIC","BIC")))
for ( maxh in 1:50) {
fs <- summary( fit <- lm( y ~ cs(x,1:maxh), d))
measures[maxh,] <- c(maxh, fit$df[1],100*fs$r.squared , 100*fs$adj.r.squared,logLik(fit),
-2*logLik(fit),  AIC(fit), BIC(fit))
}
round(measures,2)
## seleccion del n?mero de harmonicos por CV
## seleccion del n?mero de harmonicos por CV
set.seed(353)
N = 100
x = sort(runif(N))
y = rnorm(N,sin(4*x),1/3)
plot(x,y,main="Regresi?n y Suavizadores")
x2 = seq(0,1,length=1000)
lines(x2,sin(4*x2))
d = data.frame(x=x,y=y)
#######################
# Modelado param?trico
#######################
## funci?n que construye la matriz del dise?o asociado a polinomios trigonometricos
#
# Periodic model using sines and cosines
#
cs <- function(t,harmonics=1) {
# generate matrix with sin,cos pairs with period 1
ret <- numeric(0)
for ( i in harmonics) {
ret <- cbind( ret, cos(2*pi*i*t), sin(2*pi*i*t))
}
if (missing(harmonics)) cnames <- c('c','s')
else {
cnames <- paste( c("c","s"), rep(harmonics, each = 2),sep=".")
}
colnames(ret) <- cnames
ret
}
# Ajustes con diferente grado de complejidad
fit.cs= lm(y~cs(x),d)
summary(fit.cs)   # can we drop a term??
anova(fit.cs)     # here anova respects 'marginality'
plot( d$x, d$y)
dtest=data.frame(x=x2)
lines( x2 , predict(fit.cs,dtest),col='red')
lines( x2, predict( lm( y ~ cs(x,1:4),d),dtest),col='green')
require(stats4)
measures <- matrix(NA,nrow=50,ncol=8,
,dimnames=list(NULL,c("H","df","R.sq","Adj.R.sq","logLik",
"-2logLik","AIC","BIC")))
for ( maxh in 1:50) {
fs <- summary( fit <- lm( y ~ cs(x,1:maxh), d))
measures[maxh,] <- c(maxh, fit$df[1],100*fs$r.squared , 100*fs$adj.r.squared,logLik(fit),
-2*logLik(fit),  AIC(fit), BIC(fit))
}
round(measures,2)
## seleccion del n?mero de harmonicos por CV
library(boot)
eep <- rep(NA,20)
for ( harmonic in 1:20 )  {
eep[harmonic] <- cv.glm( d, glm( y ~ cs(x, 1:harmonic), data = d), K = 10)$delta[2]
}
plot(eep,type = 'b')
eep
max(eep)
min(eep)
plot(eep,type = 'b')
## minimum around 2   ????
# fit model using all data
fit.cv <- lm( y ~ cs(x,1:2), d)
plot( d$x, d$y)
lines( d$x, predict(fit.cv))
